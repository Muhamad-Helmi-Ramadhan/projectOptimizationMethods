# -*- coding: utf-8 -*-
"""Program1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TRhqCy_xH1DZLa6E1uXOd7aXWSKE8ih4
"""

# Data awal
items = [
    {"name": "Konsumsi", "cost": 2000000, "value": 10},
    {"name": "Transport", "cost": 1000000, "value": 7},
    {"name": "Internet", "cost": 500000, "value": 6},
    {"name": "Investasi", "cost": 1500000, "value": 4},
    {"name": "Hiburan", "cost": 1000000, "value": 2}
]

budget = 3000000  # Ganti sesuai kebutuhan

# Pisahkan konsumsi dari item lain
konsumsi = items[0]
other_items = items[1:]

# Hitung rasio value/cost untuk other_items
for item in other_items:
    item["ratio"] = item["value"] / item["cost"]

# Urutkan other_items berdasarkan rasio descending
other_items.sort(key=lambda x: x["ratio"], reverse=True)

max_value = 0
best_solution = []

def bound(level, current_cost, current_value, items_list, budget_limit):
    total_cost = current_cost
    bound_value = current_value
    for i in range(level, len(items_list)):
        if total_cost + items_list[i]["cost"] <= budget_limit:
            total_cost += items_list[i]["cost"]
            bound_value += items_list[i]["value"]
        else:
            remaining = budget_limit - total_cost
            bound_value += items_list[i]["value"] * (remaining / items_list[i]["cost"])
            break
    return bound_value

def branch_and_bound(level, current_cost, current_value, taken, items_list, budget_limit):
    global max_value, best_solution

    if current_cost > budget_limit:
        return

    if current_value > max_value:
        max_value = current_value
        best_solution = taken.copy()

    if level == len(items_list):
        return

    if bound(level, current_cost, current_value, items_list, budget_limit) <= max_value:
        return

    # Ambil item
    taken[level] = 1
    branch_and_bound(level + 1,
                     current_cost + items_list[level]["cost"],
                     current_value + items_list[level]["value"],
                     taken,
                     items_list,
                     budget_limit)

    # Tidak ambil item
    taken[level] = 0
    branch_and_bound(level + 1,
                     current_cost,
                     current_value,
                     taken,
                     items_list,
                     budget_limit)

# EKSEKUSI

total_cost = 0
total_value = 0
final_solution = []

if budget >= konsumsi["cost"]:
    # Konsumsi wajib masuk
    total_cost += konsumsi["cost"]
    total_value += konsumsi["value"]
    # Jalankan branch and bound untuk item lain dengan sisa budget
    max_value = 0
    best_solution = [0] * len(other_items)
    branch_and_bound(0, 0, 0, [0] * len(other_items), other_items, budget - konsumsi["cost"])

    # Gabungkan solusi konsumsi + hasil branch and bound
    final_solution = [1] + best_solution
    total_cost += sum(other_items[i]["cost"] for i in range(len(other_items)) if best_solution[i] == 1)
    total_value += max_value
else:
    # Budget kurang, jalankan branch and bound biasa untuk semua item
    max_value = 0
    best_solution = [0] * len(items)
    branch_and_bound(0, 0, 0, [0] * len(items), items, budget)
    final_solution = best_solution
    total_cost = sum(items[i]["cost"] for i in range(len(items)) if best_solution[i] == 1)
    total_value = max_value

# OUTPUT HASIL
print("=== HASIL OPTIMAL DENGAN PRIORITAS KONSUMSI ===")
for i, item in enumerate(items):
    if final_solution[i] == 1:
        print(f"- {item['name']}")
print(f"Total Biaya     : Rp {total_cost:,}")
print(f"Total Prioritas : {total_value}")